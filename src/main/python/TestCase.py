#
# This file is hereby placed into the Public Domain.
# This means anyone is free to do whatever they wish with this file.
#

import sys
import array
import numpy
import struct
import math


WIDTH  = 800
HEIGHT = 600
"""
The raster size, in pixels.
"""


NUM_INTERPOLATION_POINTS = 20000
"""
Number of points where to interpolate.
"""


NUM_VERIFIED_ITERATIONS = 10
"""
Number of iterations for which we verify the conformance against expected results.
We verify a small number of iterations because the actual results diverge strongly
from the expected results after about 8 iterations, because of the intentionally
chaotic nature of the calculation.
"""


MISSING_VALUE_THRESHOLD = 10000
"""
The threshold used for deciding if a value should be considered as a missing value
when using the "no data" sentinel values approach instead of IEEE 754 NaN values.
Any value greater than this threshold will be considered a missing value.
"""


FIRST_QUIET_NAN = 0x7FC00000
"""
Value of the first positive quiet NaN.
"""


UNKNOWN = FIRST_QUIET_NAN
CLOUD   = FIRST_QUIET_NAN + 1
LAND    = FIRST_QUIET_NAN + 2
NO_PASS = FIRST_QUIET_NAN + 3
"""
NaN bit pattern for a missing data. A value may be missing for different reasons, which are identified
by different NaN values. This test uses the following values, in precedence order. For example,
if a calculation involves two pixels missing for `CLOUD` and `LAND` reasons respectively,
then the result will be considered missing for the `LAND` reason.

  - Missing because the remote sensor didn't pass over that area.
  - Missing because the pixel is on a land (assuming that the data are for some oceanographic phenomenon).
  - Missing because of a cloud.
  - Missing for an unknown reason.
"""


def floatToRawIntBits(f):
    """
    Returns the bits of the given floating point number.
    This is needed for inspecting which NaN was obtained.
    """
    s = struct.pack('>f', f)
    return struct.unpack('>i', s)[0]


directory = 'target/generated-data/nan/'
"""
The directory where to look for binary files. Those files are generated by the Java test.
For making this Python demo simpler, we test only the case using NaN values.
We do not test the case using "no data" sentinel values.
"""


error_statistics = array.array('d')
"""
Statistics about the differences between computed values and expected values.
The array length is `NUM_VERIFIED_ITERATIONS`.
"""


nodata_mismatches = array.array('i')
"""
Number of times where the "no data" values do not match the expected values.
This value should be zero during the first iterations, and become non-zero only
after the calculation has drifted. Note that the latter case is not an indication
that NaN does no work: identical mismatches happen with the "no data" approach too.
"""


def load_raster():
    """
    Loads a RAW file containing raster data as `float` values in the native endianness ('big' or 'little').
    The raster size is 'WIDTH' Ã— 'HEIGHT' pixels and the values are random 'float' values between -100 and +100.
    The file contains random missing values identified by 4 distinct NaN values.
    """
    bytes = array.array('B')
    path = directory + sys.byteorder + '-endian.raw'
    with open(path, 'rb') as f:
        bytes.fromfile(f, 1920000)
    return numpy.frombuffer(bytes, dtype=numpy.float32)


def to_native_byte_order(bytes):
    """
    Swaps byte order from big endian to little endian if needed on the host machine.
    Data are returned as an array of `double` values.
    """
    values = array.array('d')
    for i in range(0, len(bytes), 8):
        values.append(struct.unpack_from('>d', bytes, i)[0])
    return values


def load_coordinates():
    """
    Loads a RAW file containing pixel coordinates as `double` values in big-endian byte order.
    For simplicity, coordinates are from 0 inclusive to the width or height minus one, exclusive.
    This is for avoiding the need to check for bounds before bilinear interpolations.
    """
    bytes = array.array('B')
    with open(directory + 'coordinates.raw', 'rb') as f:
        bytes.fromfile(f, 320000)
    return to_native_byte_order(bytes)


def load_expected_results():
    """
    Loads a RAW file containing expected results as `double` values in big-endian byte order.
    Missing results are represented by sentinel values only. NaNs are not used for avoiding
    any suspicion about test reliability.
    """
    bytes = array.array('B')
    with open(directory + 'expected-results.raw', 'rb') as f:
        bytes.fromfile(f, 1600000)
    return to_native_byte_order(bytes)


def print_statistics():
    """
    Prints the statistics collected by this test.
    The test is considered successful if the first iterations have no errors.
    A drift is tolerated in the last iterations because this test intentionally
    uses chaotic algorithm in order to test the effect of optimizations enabled
    by compiler options in the C/C++ variant of this test.
    """
    print("Errors in the use of raster data with NaN values in " + sys.byteorder + "-endian byte order:")
    print("    Maximum   Number of \"missing value\" mismatches")
    for i in range(0, len(nodata_mismatches)):
        print("%11.4f %6d" % (error_statistics[i], nodata_mismatches[i]))


def compute_and_compare():
    """
    Reads the raster, performs interpolations and compares against the expected values.
    Differences are collected in statistics that can be printed with `print_statistics()`.
    This method is the interesting part of the tests, where both approaches (NaN versus "no data") differ.
    """
    raster = load_raster()
    coordinates = load_coordinates()
    expected_results = load_expected_results()
    result_index = 0
    for it in range(0, NUM_VERIFIED_ITERATIONS):
        stats = 0
        mismatches = 0
        for i in range(0, NUM_INTERPOLATION_POINTS):
            expected = expected_results[result_index]
            #
            # Get all sample values that we need for the bilinear interpolation.
            # Variables starting with "v" are converted from `float` to `double`.
            #
            ix = i * 2
            iy = ix + 1
            x  = coordinates[ix]
            y  = coordinates[iy]
            xb = math.floor(x)
            yb = math.floor(y)

            offset = WIDTH * yb + xb
            v00 = raster[offset]
            v01 = raster[offset + 1]
            v10 = raster[offset + WIDTH]
            v11 = raster[offset + WIDTH + 1]
            #
            # Apply bilinear interpolation. Contrarily to the `TestNodata` case, we compute
            # this interpolation unconditionally without checking if the data are valid.
            # This is an arbitrary choice, we could have made the two codes more similar.
            # We do that for illustrating this flexibility, and for showing that we can
            # rely on the result being some kind of NaN on all platforms and languages.
            #
            # NOTE ON FLOATING POINT PRECISION:
            # The addition of 0.0 is a hack for forcing Python to convert 32 bit floating point numbers
            # (single precision) to 64 bits floating point numbers (double precision) before to do the
            # subtraction. Otherwise, (v01 - v00) and (v11 - v10) are computed with single precision,
            # causing the results to diverge from expected results. This issue is unrelated to NaN.
            #
            xf = x - xb
            yf = y - yb
            v0 = (v01 - (v00 + 0.0)) * xf + v00     # See above for the +0.0 hack
            v1 = (v11 - (v10 + 0.0)) * xf + v10
            result = (v1 - v0) * yf + v0
            #
            # Check if any raster value is missing. We could perform this check before calculation as in
            # `TestNodata` class, but we don't have to. This demo arbitrarily checks after calculation.
            # As an optimization, we exploit the facts that in this test:
            #
            #   1) All NaN values in this test are "positive" (sign bit set to 0).
            #   2) NaN payloads are sorted with higher values for the reasons having precedence.
            #
            # The combination of those two facts allows us to simply check for the maximal value,
            # using signed integer comparisons, no matter if we have a mix of "no data" and real values.
            # If fact #1 was not true, we could still apply the same trick with only the addition of a bitmask.
            #
            if math.isnan(result):
                missing_value_reason = max(
                        max(floatToRawIntBits(v00), floatToRawIntBits(v01)),
                        max(floatToRawIntBits(v10), floatToRawIntBits(v11)))
                #
                # Convert the NaN pattern to the "no data" sentinel value used by `DataGenerator`.
                # This step is not needed in an application using NaN. This test is doing that
                # conversion only because we choose to store missing values as "no data" in the
                # "expected-results.raw" file.
                #
                nodata = (missing_value_reason - FIRST_QUIET_NAN) + MISSING_VALUE_THRESHOLD
                if nodata != expected:
                    mismatches += 1
                result = 1
            else:
                if expected >= MISSING_VALUE_THRESHOLD:
                    mismatches += 1
                else:
                    stats = max(stats, math.fabs(result - expected));
            coordinates[ix] = math.fmod(math.fabs(x + result), WIDTH  - 1);
            coordinates[iy] = math.fmod(math.fabs(y + result), HEIGHT - 1);
            result_index += 1;
        error_statistics.append(stats);
        nodata_mismatches.append(mismatches)


compute_and_compare()
print_statistics()
